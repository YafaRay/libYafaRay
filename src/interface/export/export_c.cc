/****************************************************************************
 *      This is part of the libYafaRay package
 *
 *      This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *      Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include "interface/export/export_c.h"
#include "common/logger.h"
#include "scene/scene.h"
#include "geometry/matrix.h"
#include "geometry/primitive/face_indices.h"
#include "param/param.h"
#include "render/progress_bar.h"

namespace yafaray {

ExportC::ExportC(const char *fname, const ::yafaray_LoggerCallback logger_callback, void *callback_data, ::yafaray_DisplayConsole logger_display_console) : Interface(logger_callback, callback_data, logger_display_console), file_name_(std::string(fname))
{
	file_.open(file_name_.c_str());
	if(!file_.is_open())
	{
		logger_->logError("CExport: Couldn't open ", file_name_);
		return;
	}
	else logger_->logInfo("CExport: Writing scene to: ", file_name_);
	file_ << generateHeader();
}

std::string ExportC::generateHeader()
{
	std::stringstream ss;
	ss << "/* ANSI C89/C90 file generated by libYafaRay C Export */\n";
	ss << "/* To build use your favorite ANSI C compiler/linker, pointing to libYafaRay include/library files */\n";
	ss << "/* For example in Linux using GCC */\n";
	ss << "/* LD_LIBRARY_PATH=(path to folder with libyafaray libs) gcc -o libyafaray_example_executable -ansi -I(path to folder with libyafaray includes) -L(path to folder with libyafaray libs) (yafaray_scene_exported_source_file_name.c) -O0 -ggdb -lyafaray4 */\n";
	ss << "/* Note: no optimizations are needed for compiling this source file because it is libYafaRay itself which should be optimized for fastest execution. */\n";
	ss << "/*       Disabling compiler optimizations should help speeding up compilation of large scenes. */\n";
	ss << "/* To run the executable */\n";
	ss << "/* LD_LIBRARY_PATH=(path to folder with libyafaray libs) ./libyafaray_example_executable */\n\n";
	ss << "#include <yafaray_c_api.h>\n";
	ss << "void section_0(yafaray_Interface_t *yi)\n{\n";
	return ss.str();
}

std::string ExportC::generateMain() const
{
	std::stringstream ss;
	ss << "int main()\n";
	ss << "{\n";
	ss << "\t" << "yafaray_Interface_t *yi = yafaray_createInterface(YAFARAY_INTERFACE_FOR_RENDERING, NULL, NULL, NULL, YAFARAY_DISPLAY_CONSOLE_NORMAL);\n";
	ss << "\t" << "yafaray_setConsoleLogColorsEnabled(yi, true);\n";
	ss << "\t" << "yafaray_setConsoleVerbosityLevel(yi, YAFARAY_LOG_LEVEL_VERBOSE);\n\n";
	ss << generateSectionsCalls();
	ss << "\n\t" << "yafaray_render(yi, NULL, NULL, YAFARAY_DISPLAY_CONSOLE_NORMAL);\n";
	ss << "\n\t" << "yafaray_destroyInterface(yi);\n\n";
	ss << "\t" << "return 0;\n";
	ss << "}\n";
	return ss.str();
}

std::string ExportC::generateSectionsCalls() const
{
	std::stringstream ss;
	for(int section = 0; section < num_sections_; ++section)
	{
		ss << "\t" << "section_" << section << "(yi);\n";
	}
	return ss.str();
}

std::string ExportC::sectionSplit()
{
	section_num_lines_ = 0;
	std::stringstream ss;
	ss << "}\n\n";
	ss << "void section_" << num_sections_ << "(yafaray_Interface_t *yi)\n{\n";
	++num_sections_;
	return ss.str();
}

void ExportC::createScene() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createScene(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n";
	section_num_lines_ += 2;
}

void ExportC::clearAll() noexcept
{
	if(logger_->isVerbose()) logger_->logVerbose("CExport: cleaning up...");
	if(file_.is_open())
	{
		file_.flush();
		file_.close();
	}
	params_->clear();
	nodes_params_.clear();
	cparams_ = params_.get();
	next_obj_ = 0;
}

void ExportC::defineLayer() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineLayer(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
}

bool ExportC::initObject(size_t object_id, size_t material_id) noexcept
{
	file_ << "\t" << "yafaray_endObject(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	return true;
}

int ExportC::addVertex(size_t object_id, Point3f &&vertex, unsigned char time_step) noexcept
{
	file_ << "\t" << "yafaray_addVertex(yi, " << vertex[Axis::X] << ", " << vertex[Axis::Y] << ", " << vertex[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return 0;
}

int ExportC::addVertex(size_t object_id, Point3f &&vertex, Point3f &&orco, unsigned char time_step) noexcept
{
	file_ << "\t" << "yafaray_addVertexWithOrco(yi, " << vertex[Axis::X] << ", " << vertex[Axis::Y] << ", " << vertex[Axis::Z] << ", " << orco[Axis::X] << ", " << orco[Axis::Y] << ", " << orco[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return 0;
}

void ExportC::addVertexNormal(size_t object_id, Vec3f &&normal, unsigned char time_step) noexcept
{
	file_ << "\t" << "yafaray_addNormal(yi, " << normal[Axis::X] << ", " << normal[Axis::Y] << ", " << normal[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
}

bool ExportC::addFace(size_t object_id, const FaceIndices<int> &face_indices, size_t material_id) noexcept
{
	const int num_vertices{face_indices.numVertices()};
	const bool has_uv{face_indices.hasUv()};
	if(has_uv)
	{
		if(num_vertices == 3) file_ << "\t" << "yafaray_addTriangleWithUv(yi, ";
		else file_ << "\t" << "yafaray_addQuadWithUv(yi, ";
	}
	else
	{
		if(num_vertices == 3) file_ << "\t" << "yafaray_addTriangle(yi, ";
		else file_ << "\t" << "yafaray_addQuad(yi, ";
	}

	for(int i = 0; i < num_vertices; ++i)
	{
		if(i > 0) file_ << ", ";
		file_ << face_indices[i].vertex_;
	}
	if(has_uv)
	{
		for(int i = 0; i < num_vertices; ++i)
		{
			file_ << ", " << face_indices[i].uv_;
		}
	}
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

int ExportC::addUv(size_t object_id, Uv<float> &&uv) noexcept
{
	file_ << "\t" << "yafaray_addUv(yi, " << uv.u_ << ", " << uv.v_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return n_uvs_++;
}

bool ExportC::smoothVerticesNormals(size_t object_id, double angle) noexcept
{
	file_ << "\t" << "yafaray_smoothObjectMesh(yi, \"" << object_id << "\", " << angle << ");\n\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

void ExportC::writeMatrix(const Matrix4f &m, std::ofstream &file) noexcept
{
	file <<
			m[0][0] << ", " << m[0][1] << ", " << m[0][2] << ", " << m[0][3] << ", " <<
			m[1][0] << ", " << m[1][1] << ", " << m[1][2] << ", " << m[1][3] << ", " <<
			m[2][0] << ", " << m[2][1] << ", " << m[2][2] << ", " << m[2][3] << ", " <<
			m[3][0] << ", " << m[3][1] << ", " << m[3][2] << ", " << m[3][3];
}

void ExportC::writeParam(const std::string &name, const Parameter &param, std::ofstream &file, ColorSpace color_space, float gamma) noexcept
{
	const Parameter::Type type = param.type();
	if(type == Parameter::Type::Int)
	{
		int i = 0;
		param.getVal(i);
		file << "yafaray_setParamMapInt(yi, \"" << name << "\", " << i << ");\n";
	}
	else if(type == Parameter::Type::Bool)
	{
		bool b = false;
		param.getVal(b);
		file << "yafaray_setParamMapBool(yi, \"" << name << "\", " << (b ? "true" : "false") << ");\n";
	}
	else if(type == Parameter::Type::Float)
	{
		double f = 0.0;
		param.getVal(f);
		file << "yafaray_setParamMapFloat(yi, \"" << name << "\", " << f << ");\n";
	}
	else if(type == Parameter::Type::String)
	{
		std::string s;
		param.getVal(s);
		file << "yafaray_setParamMapString(yi, \"" << name << "\", \"" << s << "\");\n";
	}
	else if(type == Parameter::Type::Vector)
	{
		Point3f p{{0.f, 0.f, 0.f}};
		param.getVal(p);
		file << "yafaray_setParamMapVector(yi, \"" << name << "\", " << p[Axis::X] << ", " << p[Axis::Y] << ", " << p[Axis::Z] << ");\n";
	}
	else if(type == Parameter::Type::Color)
	{
		Rgba c(0.f);
		param.getVal(c);
		c.colorSpaceFromLinearRgb(color_space, gamma);    //Color values are encoded to the desired color space before saving them to the XML file
		file << "yafaray_setParamMapColor(yi, \"" << name << "\", " << c.r_ << ", " << c.g_ << ", " << c.b_ << ", " << c.a_ << ");\n";
	}
	else if(type == Parameter::Type::Matrix)
	{
		Matrix4f m;
		param.getVal(m);
		file << "yafaray_setParamMapMatrix(yi, ";
		writeMatrix(m, file);
		file << ", false);\n";
	}
	else
	{
		std::cerr << "unknown parameter type!\n";
	}
}

size_t ExportC::createInstance() noexcept
{
	file_ << "\t" << "yafaray_createInstance(yi);\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return current_instance_id_++;
}

bool ExportC::addInstanceObject(size_t instance_id, size_t base_object_id) noexcept
{
	file_ << "\t" << "yafaray_addInstanceObject(yi, " << instance_id << ", \"" << base_object_id << "\");\n"; //FIXME Should I use the variable name "instance_id" for export instead?
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

bool ExportC::addInstanceOfInstance(size_t instance_id, size_t base_instance_id) noexcept
{
	file_ << "\t" << "yafaray_addInstanceOfInstance(yi, " << instance_id << ", " << base_instance_id << ");\n"; //FIXME Should I use the variable name "instance_id" for export instead?
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

bool ExportC::addInstanceMatrix(size_t instance_id, Matrix4f &&obj_to_world, float time) noexcept
{
	file_ << "\t" << "yafaray_addInstanceMatrix(yi, " << instance_id << ", "; //FIXME Should I use the variable name "instance_id" for export instead?
	writeMatrix(obj_to_world, file_);
	file_ << ", " << time << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

void ExportC::writeParamMap(const ParamMap &param_map, int indent) noexcept
{
	const std::string tabs(indent, '\t');
	for(const auto &[param_name, param] : param_map)
	{
		file_ << tabs;
		writeParam(param_name, param, file_, color_space_, gamma_);
		++section_num_lines_;
	}
}

void ExportC::writeParamList(int indent) noexcept
{
	const std::string tabs(indent, '\t');
	for(const auto &param : nodes_params_)
	{
		file_ << tabs << "yafaray_addParamMapToList(param_map_list, param_map);\n";
		writeParamMap(param, indent + 1);
	}
	file_ << tabs << "yafaray_paramsEndList(yi);\n";
	++section_num_lines_;
}

std::pair<size_t, ParamResult> ExportC::createLight(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createLight(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createTexture(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createTexture(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createMaterial(const std::string &name) noexcept
{
	writeParamMap(*params_);
	writeParamList(1);
	params_->clear();
	nodes_params_.clear();
	file_ << "\t" << "yafaray_createMaterial(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createCamera(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineCamera(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

ParamResult ExportC::defineBackground() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineBackground(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

ParamResult ExportC::defineSurfaceIntegrator() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineSurfaceIntegrator(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

ParamResult ExportC::defineVolumeIntegrator() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineVolumeIntegrator(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createVolumeRegion(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createVolumeRegion(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createOutput(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createOutput(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createRenderView(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createRenderView(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createImage(const std::string &name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createImage(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return {};
}

std::pair<size_t, ParamResult> ExportC::createObject(const std::string &name) noexcept
{
	n_uvs_ = 0;
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createObject(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	++next_obj_;
	return {next_obj_ - 1, ParamResult{}};
}

void ExportC::setupRender() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_setupRender(yi);\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n\n";
	section_num_lines_ += 2;
}

void ExportC::render(std::unique_ptr<ProgressBar> progress_bar) noexcept
{
	file_ << "\t" << "/* Creating image output */\n";
	file_ << "\t" << "yafaray_setParamMapString(yi, \"image_path\", \"./test01-output1.tga\");\n";
	file_ << "\t" << "yafaray_setParamMapString(yi, \"color_space\", \"sRGB\");\n";
	file_ << "\t" << "yafaray_setParamMapString(yi, \"badge_position\", \"top\");\n";
	file_ << "\t" << "yafaray_createOutput(yi, \"output1_tga\");\n";
	file_ << "\t" << "yafaray_clearParamMap(param_map);\n";
	file_ << "}\n\n";
	params_->clear();
	nodes_params_.clear();
	file_ << generateMain();
	file_.flush();
	file_.close();
}

void ExportC::setColorSpace(const std::string& color_space_string, float gamma_val) noexcept
{
	color_space_.initFromString(color_space_string);
	gamma_ = gamma_val;
}

} //namespace yafaray
