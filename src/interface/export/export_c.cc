/****************************************************************************
 *      This is part of the libYafaRay package
 *
 *      This library is free software; you can redistribute it and/or
 *      modify it under the terms of the GNU Lesser General Public
 *      License as published by the Free Software Foundation; either
 *      version 2.1 of the License, or (at your option) any later version.
 *
 *      This library is distributed in the hope that it will be useful,
 *      but WITHOUT ANY WARRANTY; without even the implied warranty of
 *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *      Lesser General Public License for more details.
 *
 *      You should have received a copy of the GNU Lesser General Public
 *      License along with this library; if not, write to the Free Software
 *      Foundation,Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 */

#include "interface/export/export_c.h"
#include "common/logger.h"
#include "scene/scene.h"
#include "geometry/matrix.h"
#include "common/param.h"

namespace yafaray {

ExportC::ExportC(const char *fname, const ::yafaray_LoggerCallback_t logger_callback, void *callback_data, ::yafaray_DisplayConsole_t logger_display_console) : Interface(logger_callback, callback_data, logger_display_console), file_name_(std::string(fname))
{
	file_.open(file_name_.c_str());
	if(!file_.is_open())
	{
		logger_->logError("CExport: Couldn't open ", file_name_);
		return;
	}
	else logger_->logInfo("CExport: Writing scene to: ", file_name_);
	file_ << generateHeader();
}

std::string ExportC::generateHeader()
{
	std::stringstream ss;
	ss << "/* ANSI C89/C90 file generated by libYafaRay C Export */\n";
	ss << "/* To build use your favorite ANSI C compiler/linker, pointing to libYafaRay include/library files */\n";
	ss << "/* For example in Linux using GCC */\n";
	ss << "/* LD_LIBRARY_PATH=(path to folder with libyafaray libs) gcc -o libyafaray_example_executable -ansi -I(path to folder with libyafaray includes) -L(path to folder with libyafaray libs) (yafaray_scene_exported_source_file_name.c) -O0 -ggdb -lyafaray4 */\n";
	ss << "/* Note: no optimizations are needed for compiling this source file because it is libYafaRay itself which should be optimized for fastest execution. */\n";
	ss << "/*       Disabling compiler optimizations should help speeding up compilation of large scenes. */\n";
	ss << "/* To run the executable */\n";
	ss << "/* LD_LIBRARY_PATH=(path to folder with libyafaray libs) ./libyafaray_example_executable */\n\n";
	ss << "#include <yafaray_c_api.h>\n";
	ss << "#define NULL 0\n\n";
	ss << "void section_0(yafaray_Interface_t *yi)\n{\n";
	return ss.str();
}

std::string ExportC::generateMain() const
{
	std::stringstream ss;
	ss << "int main()\n";
	ss << "{\n";
	ss << "\t" << "yafaray_Interface_t *yi = yafaray_createInterface(YAFARAY_INTERFACE_FOR_RENDERING, NULL, NULL, NULL, YAFARAY_DISPLAY_CONSOLE_NORMAL);\n";
	ss << "\t" << "yafaray_setConsoleLogColorsEnabled(yi, YAFARAY_BOOL_TRUE);\n";
	ss << "\t" << "yafaray_setConsoleVerbosityLevel(yi, YAFARAY_LOG_LEVEL_DEBUG);\n\n";
	ss << generateSectionsCalls();
	ss << "\n\t" << "yafaray_render(yi, NULL, NULL, YAFARAY_DISPLAY_CONSOLE_NORMAL);\n";
	ss << "\n\t" << "yafaray_destroyInterface(yi);\n\n";
	ss << "\t" << "return 0;\n";
	ss << "}\n";
	return ss.str();
}

std::string ExportC::generateSectionsCalls() const
{
	std::stringstream ss;
	for(int section = 0; section < num_sections_; ++section)
	{
		ss << "\t" << "section_" << section << "(yi);\n";
	}
	return ss.str();
}

std::string ExportC::sectionSplit()
{
	section_num_lines_ = 0;
	std::stringstream ss;
	ss << "}\n\n";
	ss << "void section_" << num_sections_ << "(yafaray_Interface_t *yi)\n{\n";
	++num_sections_;
	return ss.str();
}

void ExportC::createScene() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createScene(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n";
	section_num_lines_ += 2;
}

void ExportC::clearAll() noexcept
{
	if(logger_->isVerbose()) logger_->logVerbose("CExport: cleaning up...");
	if(file_.is_open())
	{
		file_.flush();
		file_.close();
	}
	params_->clear();
	nodes_params_.clear();
	cparams_ = params_.get();
	next_obj_ = 0;
}

void ExportC::defineLayer() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineLayer(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
}

bool ExportC::startGeometry() noexcept { return true; }

bool ExportC::endGeometry() noexcept { return true; }

unsigned int ExportC::getNextFreeId() noexcept
{
	return ++next_obj_;
}

bool ExportC::endObject() noexcept
{
	file_ << "\t" << "yafaray_endObject(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	return true;
}

int ExportC::addVertex(Point3f &&vertex, int time_step) noexcept
{
	file_ << "\t" << "yafaray_addVertex(yi, " << vertex[Axis::X] << ", " << vertex[Axis::Y] << ", " << vertex[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return 0;
}

int ExportC::addVertex(Point3f &&vertex, Point3f &&orco, int time_step) noexcept
{
	file_ << "\t" << "yafaray_addVertexWithOrco(yi, " << vertex[Axis::X] << ", " << vertex[Axis::Y] << ", " << vertex[Axis::Z] << ", " << orco[Axis::X] << ", " << orco[Axis::Y] << ", " << orco[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return 0;
}

void ExportC::addVertexNormal(Vec3f &&normal, int time_step) noexcept
{
	file_ << "\t" << "yafaray_addNormal(yi, " << normal[Axis::X] << ", " << normal[Axis::Y] << ", " << normal[Axis::Z];
	if(time_step > 0) file_ << ", " << time_step;
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
}

void ExportC::setCurrentMaterial(std::string &&name) noexcept
{
	if(name != current_material_) //need to set current material
	{
		file_ << "\t" << "yafaray_setCurrentMaterial(yi, \"" << name << "\");\n";
		current_material_ = std::move(name);
		++section_num_lines_;
	}
}

bool ExportC::addFace(std::vector<int> &&vertices, std::vector<int> &&uv_indices) noexcept
{
	const size_t num_vertices = vertices.size();
	const size_t num_uv = uv_indices.size();
	if(num_vertices == 3 && num_uv == 0) file_ << "\t" << "yafaray_addTriangle(yi, ";
	else if(num_vertices == 3 && num_uv == 3) file_ << "\t" << "yafaray_addTriangleWithUv(yi, ";
	else if(num_vertices == 4 && num_uv == 0) file_ << "\t" << "yafaray_addQuad(yi, ";
	else if(num_vertices == 4 && num_uv == 4) file_ << "\t" << "yafaray_addQuadWithUv(yi, ";
	else return false;

	for(size_t i = 0; i < num_vertices; ++i)
	{
		if(i > 0) file_ << ", ";
		file_ << vertices[i];
	}
	for(size_t i = 0; i < num_uv; ++i)
	{
		file_ << ", " << uv_indices[i];
	}
	file_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

int ExportC::addUv(Uv<float> &&uv) noexcept
{
	file_ << "\t" << "yafaray_addUv(yi, " << uv.u_ << ", " << uv.v_ << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return n_uvs_++;
}

bool ExportC::smoothVerticesNormals(std::string &&name, double angle) noexcept
{
	file_ << "\t" << "yafaray_smoothMesh(yi, \"" << name << "\", " << angle << ");\n\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

void ExportC::writeMatrix(const Matrix4f &m, std::ofstream &file) noexcept
{
	file <<
			m[0][0] << ", " << m[0][1] << ", " << m[0][2] << ", " << m[0][3] << ", " <<
			m[1][0] << ", " << m[1][1] << ", " << m[1][2] << ", " << m[1][3] << ", " <<
			m[2][0] << ", " << m[2][1] << ", " << m[2][2] << ", " << m[2][3] << ", " <<
			m[3][0] << ", " << m[3][1] << ", " << m[3][2] << ", " << m[3][3];
}

void ExportC::writeParam(const std::string &name, const Parameter &param, std::ofstream &file, ColorSpace color_space, float gamma) noexcept
{
	const Parameter::Type type = param.type();
	if(type == Parameter::Type::Int)
	{
		int i = 0;
		param.getVal(i);
		file << "yafaray_paramsSetInt(yi, \"" << name << "\", " << i << ");\n";
	}
	else if(type == Parameter::Type::Bool)
	{
		bool b = false;
		param.getVal(b);
		file << "yafaray_paramsSetBool(yi, \"" << name << "\", " << (b ? "YAFARAY_BOOL_TRUE" : "YAFARAY_BOOL_FALSE") << ");\n";
	}
	else if(type == Parameter::Type::Float)
	{
		double f = 0.0;
		param.getVal(f);
		file << "yafaray_paramsSetFloat(yi, \"" << name << "\", " << f << ");\n";
	}
	else if(type == Parameter::Type::String)
	{
		std::string s;
		param.getVal(s);
		file << "yafaray_paramsSetString(yi, \"" << name << "\", \"" << s << "\");\n";
	}
	else if(type == Parameter::Type::Vector)
	{
		Point3f p{{0.f, 0.f, 0.f}};
		param.getVal(p);
		file << "yafaray_paramsSetVector(yi, \"" << name << "\", " << p[Axis::X] << ", " << p[Axis::Y] << ", " << p[Axis::Z] << ");\n";
	}
	else if(type == Parameter::Type::Color)
	{
		Rgba c(0.f);
		param.getVal(c);
		c.colorSpaceFromLinearRgb(color_space, gamma);    //Color values are encoded to the desired color space before saving them to the XML file
		file << "yafaray_paramsSetColor(yi, \"" << name << "\", " << c.r_ << ", " << c.g_ << ", " << c.b_ << ", " << c.a_ << ");\n";
	}
	else if(type == Parameter::Type::Matrix)
	{
		Matrix4f m;
		param.getVal(m);
		file << "yafaray_paramsSetMatrix(yi, ";
		writeMatrix(m, file);
		file << ", YAFARAY_BOOL_FALSE);\n";
	}
	else
	{
		std::cerr << "unknown parameter type!\n";
	}
}

int ExportC::createInstance() noexcept
{
	file_ << "\t" << "yafaray_createInstance(yi);\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return current_instance_id_++;
}

bool ExportC::addInstanceObject(int instance_id, std::string &&base_object_name) noexcept
{
	file_ << "\t" << "yafaray_addInstanceObject(yi, " << instance_id << ", \"" << base_object_name << "\");\n"; //FIXME Should I use the variable name "instance_id" for export instead?
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

bool ExportC::addInstanceOfInstance(int instance_id, size_t base_instance_id) noexcept
{
	file_ << "\t" << "yafaray_addInstanceOfInstance(yi, " << instance_id << ", " << base_instance_id << ");\n"; //FIXME Should I use the variable name "instance_id" for export instead?
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

bool ExportC::addInstanceMatrix(int instance_id, Matrix4f &&obj_to_world, float time) noexcept
{
	file_ << "\t" << "yafaray_addInstanceMatrix(yi, " << instance_id << ", "; //FIXME Should I use the variable name "instance_id" for export instead?
	writeMatrix(obj_to_world, file_);
	file_ << ", " << time << ");\n";
	++section_num_lines_;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return true;
}

void ExportC::writeParamMap(const ParamMap &param_map, int indent) noexcept
{
	const std::string tabs(indent, '\t');
	for(const auto &[param_name, param] : param_map)
	{
		file_ << tabs;
		writeParam(param_name, param, file_, color_space_, gamma_);
		++section_num_lines_;
	}
}

void ExportC::writeParamList(int indent) noexcept
{
	const std::string tabs(indent, '\t');
	for(const auto &param : nodes_params_)
	{
		file_ << tabs << "yafaray_paramsPushList(yi);\n";
		writeParamMap(param, indent + 1);
	}
	file_ << tabs << "yafaray_paramsEndList(yi);\n";
	++section_num_lines_;
}

Light *ExportC::createLight(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createLight(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

Texture *ExportC::createTexture(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createTexture(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

const Material *ExportC::createMaterial(std::string &&name) noexcept
{
	writeParamMap(*params_);
	writeParamList(1);
	params_->clear();
	nodes_params_.clear();
	file_ << "\t" << "yafaray_createMaterial(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

const Camera * ExportC::createCamera(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createCamera(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

const Background * ExportC::defineBackground() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineBackground(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

SurfaceIntegrator *ExportC::defineSurfaceIntegrator() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineSurfaceIntegrator(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

VolumeIntegrator *ExportC::defineVolumeIntegrator() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_defineVolumeIntegrator(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

VolumeRegion *ExportC::createVolumeRegion(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createVolumeRegion(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

ImageOutput *ExportC::createOutput(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createOutput(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

RenderView *ExportC::createRenderView(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createRenderView(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

Image *ExportC::createImage(std::string &&name) noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createImage(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	return nullptr;
}

Object *ExportC::createObject(std::string &&name) noexcept
{
	n_uvs_ = 0;
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_createObject(yi, \"" << name << "\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
	if(section_num_lines_ >= section_max_lines_) file_ << sectionSplit();
	++next_obj_;
	return nullptr;
}

void ExportC::setupRender() noexcept
{
	writeParamMap(*params_);
	params_->clear();
	file_ << "\t" << "yafaray_setupRender(yi);\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n\n";
	section_num_lines_ += 2;
}

void ExportC::render(std::shared_ptr<ProgressBar> &&progress_bar) noexcept
{
	file_ << "\t" << "/* Creating image output */\n";
	file_ << "\t" << "yafaray_paramsSetString(yi, \"image_path\", \"./test01-output1.tga\");\n";
	file_ << "\t" << "yafaray_paramsSetString(yi, \"color_space\", \"sRGB\");\n";
	file_ << "\t" << "yafaray_paramsSetString(yi, \"badge_position\", \"top\");\n";
	file_ << "\t" << "yafaray_createOutput(yi, \"output1_tga\");\n";
	file_ << "\t" << "yafaray_paramsClearAll(yi);\n";
	file_ << "}\n\n";
	params_->clear();
	nodes_params_.clear();
	file_ << generateMain();
	file_.flush();
	file_.close();
}

void ExportC::setColorSpace(const std::string& color_space_string, float gamma_val) noexcept
{
	color_space_ = Rgb::colorSpaceFromName(color_space_string, ColorSpace::Srgb);
	gamma_ = gamma_val;
}

} //namespace yafaray
